var poncho_json = {
    // Home
    home_swiper: "",

    // Meme generator
    meme_canvas: "",
    meme_canvas_two: "",
    meme_canvas_timeout: "",
    template: "with_sign",

    // Messages
    messages_timeout: ""
}

    
poncho_json.messages = {
    download: {
        success: `<p><i class="fas fa-check font--green"></i> Downloading Poncho meme.</p>
         <p class="font--small">Note: Click &nbsp;<i class="fa-solid fa-save"></i> then right-click (desktop) or hold (mobile) image for additional download options.`
    },
    edit: {
        success: '<p><i class="fas fa-check font--green"></i> Editing Poncho meme.</p>'
    },
    reset: {
        success: '<p><i class="fas fa-check font--green"></i> Poncho meme generator reset.</p>'
    },
    save: {
        success: `<p><i class="fas fa-check font--green"></i> Poncho meme saved.</p>`
    }
}
// On document ready
$(function () {
    try {
        // Initialize app
        initialize_app();
    } catch (e) {
        // console.log(e);
    }
});

function initialize_app() {
    try {
        // Load templates
        load_templates();

        // Primary
        // Init accordions
        init_accordions();

        // Init anchor tags
        init_anchor_tags();

        // Init charts
        init_charts();

        // Init lazy load
        init_lazy_load();

        // Init messages
        init_messages();

        // Init modals
        init_modals();

        // Init particles
        init_particles();

        // Init popstate
        init_popstate();

        // Init scroll
        init_scroll();

        // Init swipers
        init_swipers();

        // Read token
        read_token(true);

        // Set read token interval
        set_read_token_interval();

        // Secondary
        // Init meme generator
        init_meme_generator();
    } catch (e) {
        // console.error(e);
    }
}

function load_templates() {
    try {
        // Modals
        var html = Handlebars.templates.modals();
        $(".modals").html(html);
    } catch (e) {
        // console.error(e);
    }
}
function check_array_defined(array) {
    try {
        // Check if
        if (typeof array == "undefined" || array == null || !$.isArray(array)) {
            // Vars
            array = [];
        }
    } catch (e) {
        // console.error(e);
        array = [];
    }

    // Return
    return array;
}

function check_value_defined(value) {
    try {
        // Check if
        if (typeof value == "undefined" || value == null) {
            // Vars
            value = "";
        }
    } catch (e) {
        // console.error(e);
        // Vars
        value = "";
    }

    // Return
    return value;
}

function copy_to_clipboard(e, selector) {
    try {
        // Vars
        var selector_parent = $(e.currentTarget).closest(selector);

        // Copy to clipboard
        navigator.clipboard.writeText(e.currentTarget.value);

        // Add class
        $(selector_parent).addClass("copied");

        // Set timeout - 2 seconds
        setTimeout(function () {
            // Remove class
            $(selector_parent).removeClass("copied");
        }, 2000);
    } catch (e) {
        // console.error(e);
    }
}

function delete_search_parameter(name, action) {
    try {
        if ("URLSearchParams" in window) {
            // Vars
            var parameters = new URLSearchParams(window.location.search);

            // Delete search parametereter
            parameters.delete(name);

            // Check if
            if (check_value_defined(parameters.toString())) {
                // Vars
                var new_url = window.location.pathname + "?" + parameters.toString();
            } else {
                // Vars
                var new_url = window.location.pathname;
            }

            // Check if
            if (!get_search_parameter(name) || action == "replace") {
                // Replace history
                history.replaceState("", "", new_url);
            } else if (action == "update") {
                // Update history
                history.pushState("", "", new_url);
            }
        }
    } catch (e) {
        // console.error(e);
    }
}

function format_number_decimals(value) {
    try {
        // Check if
        if ($.isNumeric(value)) {
            // Check if
            if (value >= 1 || value <= -1) {
                // 2 decimals
                value = parseFloat(value).toFixed(2);
            } else {
                // Number zeros after decimal
                var number_zeros = -Math.floor(Math.log10(Math.abs(value)) + 1);

                // Number of decimals = number zeros + 4
                var number_decimals = number_zeros + 4;

                // Check if
                if (number_zeros > 10) {
                    // Vars
                    value = 0;
                } else {
                    // Check if
                    if (number_decimals >= 10) {
                        // Vars
                        number_decimals = 10;
                    }

                    // Format value to number of decimals and trim extra zeros
                    value = parseFloat(parseFloat(value).toFixed(number_decimals));
                }
            }
        } else {
            // Vars
            value = 0;
        }
    } catch (e) {
        // console.error(e);
    }

    // Return
    return value;
}

function format_value_percent(value, percent) {
    // Define vars
    var return_string = "";

    try {
        // Check if
        if ($.isNumeric(value)) {
            // Vars
            value = format_number_decimals(value);
            percent = parseFloat(percent).toFixed(2);

            // Vars
            var change_color = get_change_color(percent);
            var change_direction = get_change_direction(percent);

            // Vars
            return_string = `<span class="font--bold font--${change_color}">${change_direction} $${value} (${percent}%)</span>`;
        }
    } catch (e) {
        // console.error(e);
    }

    // Return
    return return_string;
}

function get_change_color(value) {
    // Define vars
    var change_color = "";

    try {
        // Check if
        if (value > 0) {
            // Vars
            change_color = "green";
        } else if (value < 0) {
            // Vars
            change_color = "red";
        } else {
            // Vars
            change_color = "white";
        }
    } catch (e) {
        // console.error(e);
    }

    // Return
    return change_color;
}

function get_change_direction(value) {
    // Define vars
    var change_direction = "";

    try {
        // Check if
        if (value < 0) {
            // Vars
            change_direction = '<i class="fas fa-long-arrow-alt-down"></i>';
        } else if (value > 0) {
            // Vars
            change_direction = '<i class="fas fa-long-arrow-alt-up"></i>';
        } else {
            // Vars
            change_direction = '';
        }
    } catch (e) {
        // console.error(e);
    }

    // Return
    return change_direction;
}

function get_search_parameter(name) {
    // Define vars
    var parameter = false;

    try {
        // Vars
        var href = window.location.pathname + window.location.search;
        var search_parameters = href.split("?");
        search_parameters = search_parameters[1];

        // Check if
        if ("URLSearchParams" in window) {
            // Search parameters
            var parameters = new URLSearchParams(search_parameters);
            parameter = check_value_defined(parameters.get(name));
        }
    } catch (e) {
        // console.log(e);
    }

    // Return
    return parameter;
}

function init_anchor_tags() {
    try {
        // On click
        $('a[href^="#"]').on("click", function (e) {
            // Vars
            var href = $(this).attr("href");

            // Check if
            if ($(".site__header .header-position-fixed").length > 0) {
                // Vars
                var headerHeight = $("header").innerHeight();
            } else {
                // Vars
                var headerHeight = 0;
            }

            // Animate
            $("html,body").animate({ scrollTop: $(href).offset().top - headerHeight - 100 }, 500);
        });
    } catch (e) {
        // console.log(e);
    }
}

function init_lazy_load() {
    try {
        // Callback
        let callback = (entries, observer) => {
            // Loop
            entries.forEach((entry) => {
                // Check if
                if (entry.intersectionRatio >= 0.1 && entry.target.style.opacity != 1) {
                    // Opacity
                    entry.target.style.opacity = 1;
                }
            });
        };

        // Options
        let options = {
            root: null,
            threshold: [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]
        }

        // Observer
        let observer = new IntersectionObserver(callback, options);

        // Select .lazy-load
        for (const target of document.querySelectorAll(".lazy-load")) {
            // Observer
            observer.observe(target);
        }
    } catch (e) {
        // console.error(e);
    }
}

function init_popstate() {
    try {
        // On browser popstate
        $(window).on("popstate", function (event) {
            // Load modal from url
            load_modal_from_url();
        });
    } catch (e) {
        // console.error(e);
    }
}

function throttle(callback, limit) {
    try {
        // Vars
        var wait = false;

        // Return
        return function (...args) {
            // Check if
            if (!wait) {
                // Callback
                callback(...args);

                // True
                wait = true;

                // Set timeout
                setTimeout(function () {
                    // False
                    wait = false;
                }, limit);
            }
        }
    } catch (e) {
        // console.error(e);
    }
}

function update_search_parameters(parameters_array, action) {
    try {
        // Check if
        if ("URLSearchParams" in window) {
            // Search parameters
            var parameters = new URLSearchParams(window.location.search);

            // Check if
            if (check_array_defined(parameters_array)) {
                // Loop
                $.each(parameters_array, function (index, value) {
                    // Check if
                    if (value.name && value.value) {
                        // Set parameters
                        parameters.set(value.name, value.value);
                    }
                });

                // New url
                if (check_value_defined(parameters.toString())) {
                    // Vars
                    var new_url = window.location.pathname + "?" + parameters.toString();
                } else {
                    // Vars
                    var new_url = window.location.pathname;
                }

                // Check if
                if (action) {
                    // Update history
                    history.pushState("", "", new_url);
                } else {
                    // Replace history
                    history.replaceState("", "", new_url);
                }
            }
        }
    } catch (e) {
        // console.error(e);
    }
}
function init_accordions() {
    try {
        // Vars
        var selector_accordions = ".accordions";

        // Check if
        if ($(selector_accordions).length > 0) {
            // Vars
            var selector_accordion = selector_accordions + " .accordion";
            var selector_accordion_all = selector_accordions + " [data-accordions-all]";
            var selector_accordion_trigger = selector_accordion + " .trigger";
            var selector_accordions_container = selector_accordions + " .accordions__container";

            // Update accordion selectors
            update_accordion_selectors();

            // Loop
            $(selector_accordions_container + ":not(.accordions--closed)").each(function (index, value) {
                try {
                    // Check if
                    if (!$(this).hasClass("accordions--init")) {
                        // Vars
                        var selector_accordion_first = ".accordion:first-child";

                        // Add class
                        $(this).addClass("accordions--init");

                        // Show first accordion
                        $(this).find(selector_accordion_first).addClass("accordion--open");
                        $(this).find(selector_accordion_first + " .trigger").attr("aria-expanded", true);
                        $(this).find(selector_accordion_first + " .accordion__panel").show();
                    };
                } catch (e) {
                    // console.error(e);
                }
            });

            // On click
            $(selector_accordion_trigger).off("click");
            $(selector_accordion_trigger).on("click", function () {
                try {
                    // Vars
                    var accordion_id = $(this).attr("aria-controls");

                    // Check if
                    if (!check_value_defined(accordion_id)) {
                        // Update accordion selectors
                        update_accordion_selectors();

                        // Vars
                        var accordion_id = $(this).attr("aria-controls");
                    }

                    // Vars
                    var accordion_open = $(this).attr("aria-expanded") === "true";
                    var selector_accordion_id = $(selector_accordion + " #" + accordion_id);

                    // Check if
                    if (accordion_open) {
                        // Close accordion
                        $(this).attr("aria-expanded", false);
                        $(this).closest(".accordion").removeClass("accordion--open");

                        // Slide up
                        $(selector_accordion_id).slideUp(250, function () {
                            // Animation complete.
                        });

                        // Hidden
                        $(selector_accordion_id).attr("hidden", "");
                    } else {
                        // Open accordion
                        $(this).attr("aria-expanded", true);
                        $(this).closest(".accordion").addClass("accordion--open");

                        // Slide down
                        $(selector_accordion_id).slideDown(250, function () {
                            // Animation complete.
                        });

                        // Remove hidden
                        $(selector_accordion_id).removeAttr("hidden");
                    }
                } catch (e) {
                    // console.error(e);
                }
            });

            // On click
            $(selector_accordion_all).off("click");
            $(selector_accordion_all).on("click", function () {
                try {
                    // Vars
                    var accordions_all = $(this).attr("data-accordions-all");
                    var accordions = $(this).closest(selector_accordions).find(".accordion");

                    // Loop
                    $(accordions).each(function (index, value) {
                        // Vars
                        var accordion_id = $(this).find(".trigger").attr("aria-controls");

                        // Check if
                        if (!check_value_defined(accordion_id)) {
                            // Update accordion selectors
                            update_accordion_selectors();

                            // Vars
                            var accordion_id = $(this).attr("aria-controls");
                        }

                        // Check if
                        if (accordions_all == "hide") {
                            // Close accordion by id
                            close_accordion_by_id(accordion_id);
                        } else {
                            // Open accordion by id
                            open_accordion_by_id(accordion_id);
                        }
                    });
                } catch (e) {
                    // console.error(e);
                }
            });
        }
    } catch (e) {
        // console.error(e);
    }
}

function close_accordion_by_id(accordion_id) {
    try {
        // Vars
        var selector_accordions = ".accordions";
        var selector_accordion = selector_accordions + " .accordion";
        var selector_accordion_id = $(selector_accordion + " #" + accordion_id);

        // Close accordion
        $(selector_accordion + " [aria-controls=" + accordion_id + "]").attr("aria-expanded", false);
        $(selector_accordion + " [aria-controls=" + accordion_id + "]").closest(".accordion").removeClass("accordion--open");

        // Hide
        $(selector_accordion_id).hide();

        // Remove hidden
        $(selector_accordion_id).attr("hidden", "");
    } catch (e) {
        // console.error(e);
    }
}

function open_accordion_by_id(accordion_id) {
    try {
        // Vars
        var selector_accordions = ".accordions";
        var selector_accordion = selector_accordions + " .accordion";
        var selector_accordion_id = $(selector_accordion + " #" + accordion_id);

        // Open accordion
        $(selector_accordion + " [aria-controls=" + accordion_id + "]").attr("aria-expanded", true);
        $(selector_accordion + " [aria-controls=" + accordion_id + "]").closest(".accordion").addClass("accordion--open");

        // Show
        $(selector_accordion_id).show();

        // Hidden
        $(selector_accordion_id).removeAttr("hidden");
    } catch (e) {
        // console.error(e);
    }
}

function update_accordion_selectors() {
    try {
        // Loop
        $(".accordions .accordions__container .accordion").each(function (index, value) {
            // Accordion trigger
            $(this).find(".trigger").attr("id", "accordion_id_" + index);
            $(this).find(".trigger").attr("aria-controls", "accordion_panel_" + index);

            // Accordion panel
            $(this).find(".accordion__panel").attr("id", "accordion_panel_" + index);
            $(this).find(".accordion__panel").attr("aria-labelledby", "accordion_id_" + index);
        });
    } catch (e) {
        // console.error(e);
    }
}
function init_charts() {
    try {
        // Init tokenomics chart
        init_tokenomics_chart();
    } catch (e) {
        // console.error(e);
    }
}

function init_tokenomics_chart() {
    try {
        // Vars
        var ctx = document.getElementById("tokenomics_chart").getContext("2d");
        var type = "pie";

        // Data
        var data = {
            labels: [
                "Team",
                "LP"
            ],
            datasets: [{
                label: "Allocation",
                data: [5, 95],
                backgroundColor: [
                    "#ff9900",
                    "#1d1fff"
                ],
                hoverOffset: 4
            }]
        }

        // Options
        var options = {
            onHover: (event, chartElement) => {
                event.native.target.style.cursor = chartElement[0] ? "pointer" : "default";
            },
            plugins: {
                legend: {
                    display: true,
                    labels: {
                        color: "#fff"
                    },
                    onHover: (event, chartElement) => {
                        event.native.target.style.cursor = chartElement ? "pointer" : "default";
                    }
                },
                tooltip: {
                    backgroundColor: "#1d1a7a",
                    callbacks: {
                        label: function (context) {
                            return " Allocation: " + context.dataset.data[context.dataIndex] + "%";
                        }
                    },
                }
            },
            rotation: 270
        }

        // Init new chart
        new Chart(ctx, {
            type: type,
            data: data,
            options: options
        });
    } catch (e) {
        // console.error(e);
    }
}
function init_messages() {
    try {
        // Vars
        var selector_messages = ".messages";

        // Close messages 
        $(selector_messages + " .close").off("click");
        $(selector_messages + " .close").on("click", function () {
            // Hide
            $(selector_messages).hide();
        });
    } catch (e) {
        // console.error(e);
    }
}

function show_messages(message) {
    try {
        // Vars
        var selector_messages = ".messages";
        var selector_message = selector_messages + " [data-name=message]";

        // Restart timer
        clearTimeout(poncho_json.messages_timeout);

        // Check if
        if (!$(selector_message).is(":visible")) {
            // Empty
            $(selector_message).empty();

            // Append
            $(selector_message).append(message);
        } else {
            // Append existing
            $(selector_message).append(message);
        }

        // Fade in
        $(selector_messages).fadeIn();

        // Set 5 second timeout
        poncho_json.messages_timeout = setTimeout(function () {
            // Fadeout
            $(selector_messages).fadeOut();
        }, 5000);
    } catch (e) {
        // console.error(e);
    }
}
function init_modals() {
    try {
        // Vars
        var modal = ".modal";
        
        // Load modal from url
        load_modal_from_url();

        // On click
        $("[data-modal-button]").off("click");
        $("[data-modal-button]").on("click", function () {
            // Vars
            var data_modal = $(this).attr("data-modal-button");

            // Show modal
            show_modal(data_modal, true);
        });

        // On click
        $(modal + ".modal__background, " + modal + " .close, " + modal + " .close-button").off("click");
        $(modal + " .modal__background, " + modal + " .close, " + modal + " .close-button").on("click", function () {
            // Hide modal
            hide_modal("", "update");
        });
    } catch (e) {
        // console.log(e);
    }
}

function load_modal_from_url() {
    try {
        // Get search parameter
        var data_modal = get_search_parameter("modal");

        // If modal 
        if (data_modal) {
            // Show modal
            show_modal(data_modal, false);
        } else {
            // Hide modal
            hide_modal("", "replace");
        }
    } catch (e) {
        // console.error(e);
    }
}

function show_modal(data_modal, update_history) {
    try {
        // Define vars
        var modal_selector = ".modal";

        // Check if
        if ($(".modal:visible").length > 0) {
            // Hide modal
            $(modal_selector).hide();

            // Show modal
            $("[data-modal=" + data_modal + "]").show();
        }else{
            // Show modal
            $("[data-modal=" + data_modal + "]").fadeIn(250);
        }

        // Show
        $("[data-modal=" + data_modal + "]").css("display", "flex");

        // Add modal content transform
        $(".modal__content").addClass("modal__content-transform");

        // Add disable scroll
        $("body").addClass("disable-scroll");

        // Vars
        var parameters_array = [
            {
                name: "modal",
                value: data_modal,
            }
        ];

        // Check if
        if (update_history) {
            // Update search parameters
            update_search_parameters(parameters_array, true);
        }
    } catch (e) {
        // console.error(e);
    }
}

function hide_modal(data_modal, action) {
    try {
        // If modal selector
        if (!data_modal) {
            // Vars
            data_modal = $(".modal:visible").attr("data-modal");
        }

        // Check if
        if ($(".modal:visible").length > 0) {
            // Hide modal
            $(".modal").fadeOut(50);
        }

        // Remove modal content transform
        $(".modal__content").removeClass("modal__content-transform");

        // Remove disable scroll
        $("body").removeClass("disable-scroll");

        // Check if
        if (data_modal) {
            // Delete search parameter
            delete_search_parameter("modal", action);
        }
    } catch (e) {
        // console.error(e);
    }
}
function init_number_counters() {
    try {
        // Init number counter
        init_number_counter();

        // On scroll
        $(window).on("scroll", function () {
            // Init number counters
            init_number_counter();
        });
    } catch (e) {
        // console.log(e);
    }
}

function animate_count_value(this_text, count_value) {
    try {
        // Animate count
        $({ countNum: this_text.text() }).animate({
            countNum: count_value
        },
            {
                duration: 2500,
                easing: "swing",
                step: function () {
                    this_text.text(Math.floor(this.countNum));
                },
                complete: function () {
                    // Check if
                    if ($(this_text).closest("[data-number]").attr("data-comma") != "Yes") {
                        // Commas
                        this_text.text(numberWithCommas(this.countNum));
                    } else {
                        // No commas
                        this_text.text(this.countNum);
                    }

                    // Update swiper
                    poncho_json.home_swiper.update();
                },
            });
    } catch (e) {
        // console.log(e);
    }
}

function format_counter_value(count_value) {
    // Vars
    var count_value_format = "";

    try {
        // Check if ratio :
        if (count_value.indexOf(":") > -1) {
            // Vars
            var count_values = count_value.split(":");
            var count_value_1 = count_values[0];
            var count_value_2 = count_values[1];

            // New count value
            count_value_format = `<span data-number-format=${count_value_1}></span>:<span data-number-format=${count_value_2}></span>`;
        } else {
            // Format large number and decimals
            count_value_format = format_large_number(count_value);
        }
    } catch (e) {
        // console.log(e);
    }

    // Return
    return count_value_format;
}

function format_large_number(count_value) {
    // Define vars
    var count_value_format = "";
    var letter = "";

    try {
        // Vars
        count_value = Number(count_value);

        // Check value
        if ($.isNumeric(count_value)) {
            // Format number
            if (count_value > 1000000000000 || count_value < -1000000000000) {
                // Trillion
                count_value = (count_value / 1000000000000).toFixed(1);
                letter = "T";
            } else if (count_value > 1000000000 || count_value < -1000000000) {
                // Billion
                count_value = (count_value / 1000000000).toFixed(1);
                letter = "B";
            } else if (count_value > 1000000 || count_value < -1000000) {
                // Million
                count_value = (count_value / 1000000).toFixed(1);
                letter = "M";
            } else if (count_value > 10000 || count_value < -10000) {
                // Thousand
                count_value = (count_value / 1000).toFixed(1);
                letter = "K";
            } else {
                // Round
                count_value = count_value.toFixed(1);
            }
        }

        // Check if decimal .
        if (count_value.indexOf(".") > -1) {
            // Vars
            var count_values = count_value.split(".");
            var count_value_1 = count_values[0];
            var count_value_2 = count_values[1];

            // Check if
            if (count_value_2 == 0 || count_value_2 == "" || typeof count_value_2 == "undefined" || count_value_2 == null) {
                // New count value
                count_value_format = `<span data-number-format=${count_value_1}></span>${letter}`;
            } else {
                // New count value
                count_value_format = `<span data-number-format=${count_value_1}></span>.<span data-number-format=${count_value_2}></span>${letter}`;
            }
        } else {
            // New count value
            count_value_format = `<span data-number-format=${count_value}></span>${letter}`;
        }
    } catch (e) {
        // console.log(e);
    }

    // Return
    return count_value_format;
}

function init_number_counter() {
    try {
        // Loop
        $(".number-counter.count").each(function () {
            // Vars
            var offset_top = $(this).offset().top - window.innerHeight + 50;

            // Check if counter in view
            if ($(window).scrollTop() > offset_top) {
                // Remove count class 
                $(this).removeClass("count");

                // Loop each counter value to format
                $($(this).find(".value [data-number]")).each(function () {
                    // Vars
                    var count_value = $(this).attr("data-number");

                    // Format counter value
                    count_value_format = format_counter_value(count_value);

                    // Append formatted counter value
                    $(this).empty().append(count_value_format);
                });

                // Loop each counter value to animate
                $($(this).find(".value [data-number-format]")).each(function () {
                    // Var
                    var this_text = $(this);
                    var count_value = $(this).attr("data-number-format");

                    // Animate count
                    animate_count_value(this_text, count_value);
                });
            }
        });
    } catch (e) {
        // console.log(e);
    }
}

function numberWithCommas(x) {
    try {
        // Commas
        return x.toString().replace(/\B(?<!\.\d*)(?=(\d{3})+(?!\d))/g, ",");
    } catch (e) {
        // console.log(e);
    }
}
function init_particles() {
    try {
        // Particle JS
        particlesJS("particles", { "particles": { "number": { "value": 150, "density": { "enable": true, "value_area": 1000 } }, "color": { "value": "#ffffff" }, "shape": { "type": "circle", "stroke": { "width": 0, "color": "#000000" }, "polygon": { "nb_sides": 5 }, "image": { "src": "img/github.svg", "width": 100, "height": 100 } }, "opacity": { "value": 1, "random": true, "anim": { "enable": true, "speed": 1, "opacity_min": 0, "sync": false } }, "size": { "value": 6, "random": true, "anim": { "enable": false, "speed": 4, "size_min": 0.3, "sync": false } }, "line_linked": { "enable": false, "distance": 150, "color": "#ffffff", "opacity": 0.4, "width": 1 }, "move": { "enable": true, "speed": 1, "direction": "none", "random": true, "straight": false, "out_mode": "out", "bounce": false, "attract": { "enable": false, "rotateX": 600, "rotateY": 600 } } }, "interactivity": { "detect_on": "canvas", "events": { "onhover": { "enable": true, "mode": "bubble" }, "onclick": { "enable": true, "mode": "repulse" }, "resize": true }, "modes": { "grab": { "distance": 400, "line_linked": { "opacity": 1 } }, "bubble": { "distance": 250, "size": 0, "duration": 2, "opacity": 0, "speed": 3 }, "repulse": { "distance": 400, "duration": 0.4 }, "push": { "particles_nb": 4 }, "remove": { "particles_nb": 2 } } }, "retina_detect": true }); var count_particles, stats, update; stats = new Stats; stats.setMode(0); stats.domElement.style.position = 'absolute'; stats.domElement.style.left = '0px'; stats.domElement.style.top = '0px'; document.body.appendChild(stats.domElement); count_particles = document.querySelector('.js-count-particles'); update = function () { stats.begin(); stats.end(); if (window.pJSDom[0].pJS.particles && window.pJSDom[0].pJS.particles.array) { count_particles.innerText = window.pJSDom[0].pJS.particles.array.length; } requestAnimationFrame(update); }; requestAnimationFrame(update);;
    } catch (e) {
        // console.error(e);
    }
}

function init_scroll() {
    try {
        // Vars
        var scroll_selector_class = ".scroll-top";
        var scroll_selector_id = "#scroll-top";
        var scroll_timeout = "";

        // On scroll
        $(window).on("scroll", throttle(function (event) {
            try {
                // Vars
                var scroll_top = $(this).scrollTop();
                var window_height = window.innerHeight;
                window_height = window_height * 1;

                // Check if
                if (scroll_top > window_height) {
                    // Fade in
                    $(scroll_selector_class).fadeIn(100);

                    // Clear timeout
                    clearTimeout(scroll_timeout)

                    // Set timeout
                    scroll_timeout = setTimeout(function () {
                        // Fade out
                        $(scroll_selector_class).fadeOut(100);
                    }, 2000);
                } else {
                    // Fade out
                    $(scroll_selector_class).fadeOut(100);
                }
            } catch (e) {
                // console.error(e);
            }
        }, 100));

        // On click
        $(scroll_selector_id).off("click");
        $(scroll_selector_id).on("click", function () {
            try {
                // Animate
                $("html, body").animate({ scrollTop: 0 }, 500);

                // Return
                return false;
            } catch (e) {
                // console.error(e);
            }
        });
    } catch (e) {
        // console.error(e);
    }
}
function init_swipers() {
    try {
        // Init about swiper
        init_about_swiper();

        // Init home swiper
        init_home_swiper();

        // Init roadmap swiper
        init_roadmap_swiper();
    } catch (e) {
        // console.error(e);
    }
}

function init_about_swiper() {
    try {
        // Define vars
        var selector_swiper = ".about-swiper";
        var data_swiper = "[data-swiper=about-swiper]";

        // Init new swiper
        new Swiper(data_swiper, {
            // Optional parameters
            direction: "horizontal",
            keyboard: {
                enabled: true,
                onlyInViewport: false,
            },
            mousewheel: {
                forceToAxis: true
            },
            navigation: {
                nextEl: selector_swiper + " .swiper-next",
                prevEl: selector_swiper + " .swiper-prev"
            },
            slidesPerView: "auto",
            slidesPerGroup: 1,
            speed: 600,
            updateOnWindowResize: true
        });
    } catch (e) {
        // console.error(e);
    }
}

function init_home_swiper() {
    try {
        // Define vars
        var selector_swiper = ".home-swiper";
        var data_swiper = "[data-swiper=home-swiper]";

        // Init new swiper
        poncho_json.home_swiper = new Swiper(data_swiper, {
            // Optional parameters
            direction: "horizontal",
            keyboard: {
                enabled: true,
                onlyInViewport: false,
            },
            mousewheel: {
                forceToAxis: true
            },
            navigation: {
                nextEl: selector_swiper + " .swiper-next",
                prevEl: selector_swiper + " .swiper-prev"
            },
            slidesPerView: "auto",
            slidesPerGroup: 1,
            updateOnWindowResize: true
        });
    } catch (e) {
        // console.error(e);
    }
}

function init_roadmap_swiper() {
    try {
        // Define vars
        var selector_swiper = ".roadmap-swiper";
        var data_swiper = "[data-swiper=roadmap-swiper]";

        // Init new swiper
        new Swiper(data_swiper, {
            // Optional parameters
            centeredSlides: true,
            centeredSlidesBounds: true,
            direction: "horizontal",
            keyboard: {
                enabled: true,
                onlyInViewport: false,
            },
            mousewheel: {
                forceToAxis: true
            },
            navigation: {
                nextEl: selector_swiper + " .swiper-next",
                prevEl: selector_swiper + " .swiper-prev"
            },
            slidesPerView: "auto",
            slidesPerGroup: 1,
            updateOnWindowResize: true
        });
    } catch (e) {
        // console.error(e);
    }
}
function read_token(initialize) {
    try {
        // Define vars
        var pair_found = false;

        // Read token
        $.ajax({
            type: "GET",
            cache: false,
            url: "https://api.dexscreener.com/latest/dex/pairs/base/0x6FD34677ecDFae4caE732A5B22F1A3082917eb15",
            success: function (response, status, xhr) {
                // Vars
                response = check_value_defined(response);
                var pair = check_value_defined(response.pair);

                // Update token ui
                pair_found = update_token_ui(initialize, pair);
            },
            error: function (XMLHttpRequest, textStatus, errorThrown) {
                // console.error(errorThrown);
            }
        }).always(() => {
            // nprogress_end();
            // Check if
            if (!pair_found) {
                // Read token backup
                read_token_backup(initialize);
            }
        });
    } catch (e) {
        // console.error(e);
    }
}

function read_token_backup(initialize) {
    try {
        // Read token
        $.ajax({
            type: "GET",
            cache: false,
            url: "https://api.dexscreener.com/latest/dex/tokens/0xc2fe011c3885277c7f0e7ffd45ff90cadc8ecd12",
            success: function (response, status, xhr) {
                // Vars
                response = check_value_defined(response);
                var pairs = check_array_defined(response.pairs);

                // Check if
                if (pairs) {
                    // Loop
                    $.each(pairs, function (index, value) {
                        // Vars
                        var address = check_value_defined(value.baseToken.address);
                        var symbol = check_value_defined(value.baseToken.symbol);
                        var chain_id = check_value_defined(value.chainId);

                        // Check if
                        if (
                            address == "0xC2fE011C3885277c7F0e7ffd45Ff90cADc8ECD12" &&
                            symbol == "PONCHO" &&
                            chain_id == "base"
                        ) {
                            // Update token ui
                            update_token_ui(initialize, value);

                            // Return
                            return false;
                        }
                    });
                }
            },
            error: function (XMLHttpRequest, textStatus, errorThrown) {
                // console.error(errorThrown);
            }
        }).always(() => {
            // nprogress_end();
        });
    } catch (e) {
        // console.error(e);
    }
}

function set_read_token_interval() {
    try {
        // Set interval - 1 min
        setInterval(function () {
            // Read token
            read_token(false);
        }, 60 * 1000);
    } catch (e) {
        // console.error(e);
    }
}

function update_token_ui(initialize, pair) {
    // Define vars
    var pair_found = false;

    try {
        // Check if
        if (pair) {
            // Vars
            var price = check_value_defined(pair.priceUsd);

            // Check if
            if (price) {
                // Vars
                var price_change = check_value_defined(pair.priceChange.h24);
                var price_string = format_value_percent(price, price_change);
                var market_cap = check_value_defined(pair.marketCap);
                var volume = check_value_defined(pair.volume.h24);
                var buys = check_value_defined(pair.txns.h24.buys);
                var sells = check_value_defined(pair.txns.h24.sells);
                var transactions = buys + sells;
                var liquidity = check_value_defined(pair.liquidity.usd);

                // Check if
                if (price_string) {
                    // Append
                    $("[data-token=price]").html(price_string);

                    // Market cap
                    $("[data-token=market_cap]").attr("data-number", market_cap);
                    $("[data-token=market_cap]").closest(".number-counter").addClass("count");

                    // Volume
                    $("[data-token=volume]").attr("data-number", volume);
                    $("[data-token=volume]").closest(".number-counter").addClass("count");

                    // Transactions
                    $("[data-token=transactions]").attr("data-number", transactions);
                    $("[data-token=transactions]").closest(".number-counter").addClass("count");

                    // Liquidity
                    $("[data-token=liquidity]").attr("data-number", liquidity);
                    $("[data-token=liquidity]").closest(".number-counter").addClass("count");

                    // Init number counters
                    init_number_counters();

                    // Update swiper
                    poncho_json.home_swiper.update();

                    // Vars
                    pair_found = true;

                    // Check if
                    if (initialize) {
                        // Set timeout
                        setTimeout(function () {
                            // Title
                            document.title = "$PONCHO: " + price + " (" + price_change + "%) | Poncho on BASE";
                        }, 5000);
                    } else {
                        // Title
                        document.title = "$PONCHO: " + price + " (" + price_change + "%) | Poncho on BASE";
                    }
                }
            }
        }


    } catch (e) {
        // console.error(e);
    }

    // Return
    return pair_found;
}
function add_gif(gif_url) {
// https://github.com/matt-way/gifuct-js
/******/ (function (modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if (installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
        /******/
      }
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
        /******/
      };
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
      /******/
    }
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function (exports, name, getter) {
/******/ 		if (!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
        /******/
      }
      /******/
    };
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function (exports) {
/******/ 		if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
        /******/
      }
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
      /******/
    };
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function (value, mode) {
/******/ 		if (mode & 1) value = __webpack_require__(value);
/******/ 		if (mode & 8) return value;
/******/ 		if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function (key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
      /******/
    };
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function (module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
      /******/
    };
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
    /******/
  })
/************************************************************************/
/******/([
/* 0 */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

      "use strict";
      __webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _lib_index_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lib_index_js__WEBPACK_IMPORTED_MODULE_0__);

      try {
        clearTimeout(poncho_json.meme_canvas_timeout);

        // Destroy fabric
        poncho_json.meme_canvas.dispose();
        poncho_json.meme_canvas = "";

        poncho_json.meme_canvas_two = document.getElementById('meme_canvas')
        var context = poncho_json.meme_canvas_two.getContext('2d');
        context.clearRect(0, 0, poncho_json.meme_canvas_two.width, poncho_json.meme_canvas_two.height);
      } catch (e) {
        // console.error(e);
      }

      poncho_json.meme_canvas = new fabric.Canvas("meme_canvas");

      // Defaults
      fabric.InteractiveFabricObject.ownDefaults = {
        ...fabric.InteractiveFabricObject.ownDefaults,
        cornerSize: 30,
        touchCornerSize: 40,
        cornerStrokeColor: "#1d48ff",
        cornerColor: "lightblue",
        cornerStyle: "circle",
        padding: 30,
        transparentCorners: false,
        cornerDashArray: [2, 2],
        borderColor: "#ffa51f",
        borderDashArray: [3, 1, 3],
        borderScaleFactor: 3
      }

      // Textbox
      var text_object = new fabric.Textbox("Create Your\nPoncho Meme", {
        fontFamily: "pricedown",
        fontSize: poncho_json.meme_canvas.height / 10,
        id: 1,
        left: 0,
        originX: "center",
        textAlign: "center",
        top: 0,
        width: poncho_json.meme_canvas.width / 1.5
      });

      // Add text
      poncho_json.meme_canvas.add(text_object);
      // poncho_json.meme_canvas.centerObjectH(text_object);
      poncho_json.meme_canvas.setActiveObject(text_object);
      poncho_json.meme_canvas.bringObjectToFront(text_object)

      // user canvas
      poncho_json.meme_canvas_two = document.getElementById('meme_canvas')
      var ctx = poncho_json.meme_canvas_two.getContext('2d')
      // gif patch canvas
      var tempCanvas = document.createElement('canvas')
      var tempCtx = tempCanvas.getContext('2d')
      // full gif canvas
      var gifCanvas = document.createElement('canvas')
      var gifCtx = gifCanvas.getContext('2d')

      // document.getElementById('loadGIF').onclick = loadGIF
      // document.getElementById('playpause').onclick = playpause
      // document.getElementById('edgedetect').onchange = () => {
      //   bEdgeDetect = !bEdgeDetect
      // }
      // document.getElementById('grayscale').onchange = () => {
      //   bGrayscale = !bGrayscale
      // }
      // document.getElementById('invert').onchange = () => {
      //   bInvert = !bInvert
      // }
      // document.getElementById('pixels').onchange = e => {
      //   pixelPercent = e.target.value
      // }

      // load the default gif
      loadGIF()
      var gif

      // load a gif with the current input url value
      function loadGIF() {
        var oReq = new XMLHttpRequest()
        oReq.open('GET', gif_url, true)
        oReq.responseType = 'arraybuffer'

        oReq.onload = function (oEvent) {
          var arrayBuffer = oReq.response // Note: not oReq.responseText
          if (arrayBuffer) {
            gif = Object(_lib_index_js__WEBPACK_IMPORTED_MODULE_0__["parseGIF"])(arrayBuffer)
            var frames = Object(_lib_index_js__WEBPACK_IMPORTED_MODULE_0__["decompressFrames"])(gif, true)
            // render the gif
            renderGIF(frames)
          }
        }

        oReq.send(null)
      }

      var playing = false
      var bEdgeDetect = false
      var bInvert = false
      var bGrayscale = false
      var pixelPercent = 100
      var loadedFrames
      var frameIndex

      function playpause() {
        playing = !playing
        if (playing) {
          renderFrame()
        }
      }

      function renderGIF(frames) {
        loadedFrames = frames
        frameIndex = 0

        poncho_json.meme_canvas_two.width = frames[0].dims.width
        poncho_json.meme_canvas_two.height = frames[0].dims.height

        gifCanvas.width = poncho_json.meme_canvas_two.width
        gifCanvas.height = poncho_json.meme_canvas_two.height

        if (!playing) {
          playpause()
        }
      }

      var frameImageData

      function drawPatch(frame) {
        var dims = frame.dims

        if (
          !frameImageData ||
          dims.width != frameImageData.width ||
          dims.height != frameImageData.height
        ) {
          tempCanvas.width = dims.width
          tempCanvas.height = dims.height
          frameImageData = tempCtx.createImageData(dims.width, dims.height)
        }

        // set the patch data as an override
        frameImageData.data.set(frame.patch)

        // draw the patch back over the canvas
        tempCtx.putImageData(frameImageData, 0, 0)

        gifCtx.drawImage(tempCanvas, dims.left, dims.top)
      }

      var edge = function (data, output) {
        var odata = output.data
        var width = gif.lsd.width
        var height = gif.lsd.height

        var conv = [-1, -1, -1, -1, 8, -1, -1, -1, -1]
        var halfside = Math.floor(3 / 2)

        for (var y = 0; y < height; y++) {
          for (var x = 0; x < width; x++) {
            var r = 0,
              g = 0,
              b = 0
            for (var cy = 0; cy < 3; cy++) {
              for (var cx = 0; cx < 3; cx++) {
                var scy = y - halfside + cy
                var scx = x - halfside + cx

                if (scy >= 0 && scy < height && scx >= 0 && scx < width) {
                  var src = (scy * width + scx) * 4
                  var f = cy * 3 + cx
                  r += data[src] * conv[f]
                  g += data[src + 1] * conv[f]
                  b += data[src + 2] * conv[f]
                }
              }
            }

            var i = (y * width + x) * 4
            odata[i] = r
            odata[i + 1] = g
            odata[i + 2] = b
            odata[i + 3] = 255
          }
        }

        return output
      }

      var invert = function (data) {
        for (var i = 0; i < data.length; i += 4) {
          data[i] = 255 - data[i] // red
          data[i + 1] = 255 - data[i + 1] // green
          data[i + 2] = 255 - data[i + 2] // blue
          data[i + 3] = 255
        }
      }

      var grayscale = function (data) {
        for (var i = 0; i < data.length; i += 4) {
          var avg = (data[i] + data[i + 1] + data[i + 2]) / 3
          data[i] = avg // red
          data[i + 1] = avg // green
          data[i + 2] = avg // blue
          data[i + 3] = 255
        }
      }

      function manipulate() {
        var imageData = gifCtx.getImageData(0, 0, gifCanvas.width, gifCanvas.height)
        var other = gifCtx.createImageData(gifCanvas.width, gifCanvas.height)

        if (bEdgeDetect) {
          imageData = edge(imageData.data, other)
        }

        if (bInvert) {
          invert(imageData.data)
        }

        if (bGrayscale) {
          grayscale(imageData.data)
        }

        // do pixelation
        var pixelsX = 5 + Math.floor((pixelPercent / 100) * (poncho_json.meme_canvas_two.width - 5))
        var pixelsY = (pixelsX * poncho_json.meme_canvas_two.height) / poncho_json.meme_canvas_two.width

        if (pixelPercent != 100) {
          ctx.mozImageSmoothingEnabled = false
          ctx.webkitImageSmoothingEnabled = false
          ctx.imageSmoothingEnabled = false
        }

        ctx.putImageData(imageData, 0, 0)
        ctx.drawImage(poncho_json.meme_canvas_two, 0, 0, poncho_json.meme_canvas_two.width, poncho_json.meme_canvas_two.height, 0, 0, pixelsX, pixelsY)
      }

      function renderFrame() {
        // get the frame
        var frame = loadedFrames[frameIndex]

        var start = new Date().getTime()

        if (frame.disposalType === 2) {
          gifCtx.clearRect(0, 0, poncho_json.meme_canvas_two.width, poncho_json.meme_canvas_two.height)
        }

        // draw the patch
        drawPatch(frame)

        // perform manipulation
        manipulate()

        // update the frame index
        frameIndex++
        if (frameIndex >= loadedFrames.length) {
          frameIndex = 0
        }

        var end = new Date().getTime()
        var diff = end - start

        if (playing) {
          // delay the next gif frame
          poncho_json.meme_canvas_timeout = setTimeout(function () {
            requestAnimationFrame(renderFrame)
            //renderFrame();
          }, Math.max(0, Math.floor(frame.delay - diff)))
        }
      }


      /***/
    }),
/* 1 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.decompressFrames = exports.decompressFrame = exports.parseGIF = void 0;

      var _gif = _interopRequireDefault(__webpack_require__(2));

      var _jsBinarySchemaParser = __webpack_require__(3);

      var _uint = __webpack_require__(4);

      var _deinterlace = __webpack_require__(5);

      var _lzw = __webpack_require__(6);

      function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

      var parseGIF = function parseGIF(arrayBuffer) {
        var byteData = new Uint8Array(arrayBuffer);
        return (0, _jsBinarySchemaParser.parse)((0, _uint.buildStream)(byteData), _gif["default"]);
      };

      exports.parseGIF = parseGIF;

      var generatePatch = function generatePatch(image) {
        var totalPixels = image.pixels.length;
        var patchData = new Uint8ClampedArray(totalPixels * 4);

        for (var i = 0; i < totalPixels; i++) {
          var pos = i * 4;
          var colorIndex = image.pixels[i];
          var color = image.colorTable[colorIndex] || [0, 0, 0];
          patchData[pos] = color[0];
          patchData[pos + 1] = color[1];
          patchData[pos + 2] = color[2];
          patchData[pos + 3] = colorIndex !== image.transparentIndex ? 255 : 0;
        }

        return patchData;
      };

      var decompressFrame = function decompressFrame(frame, gct, buildImagePatch) {
        if (!frame.image) {
          console.warn('gif frame does not have associated image.');
          return;
        }

        var image = frame.image; // get the number of pixels

        var totalPixels = image.descriptor.width * image.descriptor.height; // do lzw decompression

        var pixels = (0, _lzw.lzw)(image.data.minCodeSize, image.data.blocks, totalPixels); // deal with interlacing if necessary

        if (image.descriptor.lct.interlaced) {
          pixels = (0, _deinterlace.deinterlace)(pixels, image.descriptor.width);
        }

        var resultImage = {
          pixels: pixels,
          dims: {
            top: frame.image.descriptor.top,
            left: frame.image.descriptor.left,
            width: frame.image.descriptor.width,
            height: frame.image.descriptor.height
          }
        }; // color table

        if (image.descriptor.lct && image.descriptor.lct.exists) {
          resultImage.colorTable = image.lct;
        } else {
          resultImage.colorTable = gct;
        } // add per frame relevant gce information


        if (frame.gce) {
          resultImage.delay = (frame.gce.delay || 10) * 10; // convert to ms

          resultImage.disposalType = frame.gce.extras.disposal; // transparency

          if (frame.gce.extras.transparentColorGiven) {
            resultImage.transparentIndex = frame.gce.transparentColorIndex;
          }
        } // create canvas usable imagedata if desired


        if (buildImagePatch) {
          resultImage.patch = generatePatch(resultImage);
        }

        return resultImage;
      };

      exports.decompressFrame = decompressFrame;

      var decompressFrames = function decompressFrames(parsedGif, buildImagePatches) {
        return parsedGif.frames.filter(function (f) {
          return f.image;
        }).map(function (f) {
          return decompressFrame(f, parsedGif.gct, buildImagePatches);
        });
      };

      exports.decompressFrames = decompressFrames;

      /***/
    }),
/* 2 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports["default"] = void 0;

      var _ = __webpack_require__(3);

      var _uint = __webpack_require__(4);

      // a set of 0x00 terminated subblocks
      var subBlocksSchema = {
        blocks: function blocks(stream) {
          var terminator = 0x00;
          var chunks = [];
          var streamSize = stream.data.length;
          var total = 0;

          for (var size = (0, _uint.readByte)()(stream); size !== terminator; size = (0, _uint.readByte)()(stream)) {
            // catch corrupted files with no terminator
            if (stream.pos + size >= streamSize) {
              var availableSize = streamSize - stream.pos;
              chunks.push((0, _uint.readBytes)(availableSize)(stream));
              total += availableSize;
              break;
            }

            chunks.push((0, _uint.readBytes)(size)(stream));
            total += size;
          }

          var result = new Uint8Array(total);
          var offset = 0;

          for (var i = 0; i < chunks.length; i++) {
            result.set(chunks[i], offset);
            offset += chunks[i].length;
          }

          return result;
        }
      }; // global control extension

      var gceSchema = (0, _.conditional)({
        gce: [{
          codes: (0, _uint.readBytes)(2)
        }, {
          byteSize: (0, _uint.readByte)()
        }, {
          extras: (0, _uint.readBits)({
            future: {
              index: 0,
              length: 3
            },
            disposal: {
              index: 3,
              length: 3
            },
            userInput: {
              index: 6
            },
            transparentColorGiven: {
              index: 7
            }
          })
        }, {
          delay: (0, _uint.readUnsigned)(true)
        }, {
          transparentColorIndex: (0, _uint.readByte)()
        }, {
          terminator: (0, _uint.readByte)()
        }]
      }, function (stream) {
        var codes = (0, _uint.peekBytes)(2)(stream);
        return codes[0] === 0x21 && codes[1] === 0xf9;
      }); // image pipeline block

      var imageSchema = (0, _.conditional)({
        image: [{
          code: (0, _uint.readByte)()
        }, {
          descriptor: [{
            left: (0, _uint.readUnsigned)(true)
          }, {
            top: (0, _uint.readUnsigned)(true)
          }, {
            width: (0, _uint.readUnsigned)(true)
          }, {
            height: (0, _uint.readUnsigned)(true)
          }, {
            lct: (0, _uint.readBits)({
              exists: {
                index: 0
              },
              interlaced: {
                index: 1
              },
              sort: {
                index: 2
              },
              future: {
                index: 3,
                length: 2
              },
              size: {
                index: 5,
                length: 3
              }
            })
          }]
        }, (0, _.conditional)({
          lct: (0, _uint.readArray)(3, function (stream, result, parent) {
            return Math.pow(2, parent.descriptor.lct.size + 1);
          })
        }, function (stream, result, parent) {
          return parent.descriptor.lct.exists;
        }), {
          data: [{
            minCodeSize: (0, _uint.readByte)()
          }, subBlocksSchema]
        }]
      }, function (stream) {
        return (0, _uint.peekByte)()(stream) === 0x2c;
      }); // plain text block

      var textSchema = (0, _.conditional)({
        text: [{
          codes: (0, _uint.readBytes)(2)
        }, {
          blockSize: (0, _uint.readByte)()
        }, {
          preData: function preData(stream, result, parent) {
            return (0, _uint.readBytes)(parent.text.blockSize)(stream);
          }
        }, subBlocksSchema]
      }, function (stream) {
        var codes = (0, _uint.peekBytes)(2)(stream);
        return codes[0] === 0x21 && codes[1] === 0x01;
      }); // application block

      var applicationSchema = (0, _.conditional)({
        application: [{
          codes: (0, _uint.readBytes)(2)
        }, {
          blockSize: (0, _uint.readByte)()
        }, {
          id: function id(stream, result, parent) {
            return (0, _uint.readString)(parent.blockSize)(stream);
          }
        }, subBlocksSchema]
      }, function (stream) {
        var codes = (0, _uint.peekBytes)(2)(stream);
        return codes[0] === 0x21 && codes[1] === 0xff;
      }); // comment block

      var commentSchema = (0, _.conditional)({
        comment: [{
          codes: (0, _uint.readBytes)(2)
        }, subBlocksSchema]
      }, function (stream) {
        var codes = (0, _uint.peekBytes)(2)(stream);
        return codes[0] === 0x21 && codes[1] === 0xfe;
      });
      var schema = [{
        header: [{
          signature: (0, _uint.readString)(3)
        }, {
          version: (0, _uint.readString)(3)
        }]
      }, {
        lsd: [{
          width: (0, _uint.readUnsigned)(true)
        }, {
          height: (0, _uint.readUnsigned)(true)
        }, {
          gct: (0, _uint.readBits)({
            exists: {
              index: 0
            },
            resolution: {
              index: 1,
              length: 3
            },
            sort: {
              index: 4
            },
            size: {
              index: 5,
              length: 3
            }
          })
        }, {
          backgroundColorIndex: (0, _uint.readByte)()
        }, {
          pixelAspectRatio: (0, _uint.readByte)()
        }]
      }, (0, _.conditional)({
        gct: (0, _uint.readArray)(3, function (stream, result) {
          return Math.pow(2, result.lsd.gct.size + 1);
        })
      }, function (stream, result) {
        return result.lsd.gct.exists;
      }), // content frames
      {
        frames: (0, _.loop)([gceSchema, applicationSchema, commentSchema, imageSchema, textSchema], function (stream) {
          var nextCode = (0, _uint.peekByte)()(stream); // rather than check for a terminator, we should check for the existence
          // of an ext or image block to avoid infinite loops
          //var terminator = 0x3B;
          //return nextCode !== terminator;

          return nextCode === 0x21 || nextCode === 0x2c;
        })
      }];
      var _default = schema;
      exports["default"] = _default;

      /***/
    }),
/* 3 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.loop = exports.conditional = exports.parse = void 0;

      var parse = function parse(stream, schema) {
        var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var parent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : result;

        if (Array.isArray(schema)) {
          schema.forEach(function (partSchema) {
            return parse(stream, partSchema, result, parent);
          });
        } else if (typeof schema === 'function') {
          schema(stream, result, parent, parse);
        } else {
          var key = Object.keys(schema)[0];

          if (Array.isArray(schema[key])) {
            parent[key] = {};
            parse(stream, schema[key], result, parent[key]);
          } else {
            parent[key] = schema[key](stream, result, parent, parse);
          }
        }

        return result;
      };

      exports.parse = parse;

      var conditional = function conditional(schema, conditionFunc) {
        return function (stream, result, parent, parse) {
          if (conditionFunc(stream, result, parent)) {
            parse(stream, schema, result, parent);
          }
        };
      };

      exports.conditional = conditional;

      var loop = function loop(schema, continueFunc) {
        return function (stream, result, parent, parse) {
          var arr = [];

          while (continueFunc(stream, result, parent)) {
            var newParent = {};
            parse(stream, schema, result, newParent);
            arr.push(newParent);
          }

          return arr;
        };
      };

      exports.loop = loop;

      /***/
    }),
/* 4 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.readBits = exports.readArray = exports.readUnsigned = exports.readString = exports.peekBytes = exports.readBytes = exports.peekByte = exports.readByte = exports.buildStream = void 0;

      // Default stream and parsers for Uint8TypedArray data type
      var buildStream = function buildStream(uint8Data) {
        return {
          data: uint8Data,
          pos: 0
        };
      };

      exports.buildStream = buildStream;

      var readByte = function readByte() {
        return function (stream) {
          return stream.data[stream.pos++];
        };
      };

      exports.readByte = readByte;

      var peekByte = function peekByte() {
        var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        return function (stream) {
          return stream.data[stream.pos + offset];
        };
      };

      exports.peekByte = peekByte;

      var readBytes = function readBytes(length) {
        return function (stream) {
          return stream.data.subarray(stream.pos, stream.pos += length);
        };
      };

      exports.readBytes = readBytes;

      var peekBytes = function peekBytes(length) {
        return function (stream) {
          return stream.data.subarray(stream.pos, stream.pos + length);
        };
      };

      exports.peekBytes = peekBytes;

      var readString = function readString(length) {
        return function (stream) {
          return Array.from(readBytes(length)(stream)).map(function (value) {
            return String.fromCharCode(value);
          }).join('');
        };
      };

      exports.readString = readString;

      var readUnsigned = function readUnsigned(littleEndian) {
        return function (stream) {
          var bytes = readBytes(2)(stream);
          return littleEndian ? (bytes[1] << 8) + bytes[0] : (bytes[0] << 8) + bytes[1];
        };
      };

      exports.readUnsigned = readUnsigned;

      var readArray = function readArray(byteSize, totalOrFunc) {
        return function (stream, result, parent) {
          var total = typeof totalOrFunc === 'function' ? totalOrFunc(stream, result, parent) : totalOrFunc;
          var parser = readBytes(byteSize);
          var arr = new Array(total);

          for (var i = 0; i < total; i++) {
            arr[i] = parser(stream);
          }

          return arr;
        };
      };

      exports.readArray = readArray;

      var subBitsTotal = function subBitsTotal(bits, startIndex, length) {
        var result = 0;

        for (var i = 0; i < length; i++) {
          result += bits[startIndex + i] && Math.pow(2, length - i - 1);
        }

        return result;
      };

      var readBits = function readBits(schema) {
        return function (stream) {
          var _byte = readByte()(stream); // convert the byte to bit array


          var bits = new Array(8);

          for (var i = 0; i < 8; i++) {
            bits[7 - i] = !!(_byte & 1 << i);
          } // convert the bit array to values based on the schema


          return Object.keys(schema).reduce(function (res, key) {
            var def = schema[key];

            if (def.length) {
              res[key] = subBitsTotal(bits, def.index, def.length);
            } else {
              res[key] = bits[def.index];
            }

            return res;
          }, {});
        };
      };

      exports.readBits = readBits;

      /***/
    }),
/* 5 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.deinterlace = void 0;

      /**
       * Deinterlace function from https://github.com/shachaf/jsgif
       */
      var deinterlace = function deinterlace(pixels, width) {
        var newPixels = new Array(pixels.length);
        var rows = pixels.length / width;

        var cpRow = function cpRow(toRow, fromRow) {
          var fromPixels = pixels.slice(fromRow * width, (fromRow + 1) * width);
          newPixels.splice.apply(newPixels, [toRow * width, width].concat(fromPixels));
        }; // See appendix E.


        var offsets = [0, 4, 2, 1];
        var steps = [8, 8, 4, 2];
        var fromRow = 0;

        for (var pass = 0; pass < 4; pass++) {
          for (var toRow = offsets[pass]; toRow < rows; toRow += steps[pass]) {
            cpRow(toRow, fromRow);
            fromRow++;
          }
        }

        return newPixels;
      };

      exports.deinterlace = deinterlace;

      /***/
    }),
/* 6 */
/***/ (function (module, exports, __webpack_require__) {

      "use strict";


      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.lzw = void 0;

      /**
       * javascript port of java LZW decompression
       * Original java author url: https://gist.github.com/devunwired/4479231
       */
      var lzw = function lzw(minCodeSize, data, pixelCount) {
        var MAX_STACK_SIZE = 4096;
        var nullCode = -1;
        var npix = pixelCount;
        var available, clear, code_mask, code_size, end_of_information, in_code, old_code, bits, code, i, datum, data_size, first, top, bi, pi;
        var dstPixels = new Array(pixelCount);
        var prefix = new Array(MAX_STACK_SIZE);
        var suffix = new Array(MAX_STACK_SIZE);
        var pixelStack = new Array(MAX_STACK_SIZE + 1); // Initialize GIF data stream decoder.

        data_size = minCodeSize;
        clear = 1 << data_size;
        end_of_information = clear + 1;
        available = clear + 2;
        old_code = nullCode;
        code_size = data_size + 1;
        code_mask = (1 << code_size) - 1;

        for (code = 0; code < clear; code++) {
          prefix[code] = 0;
          suffix[code] = code;
        } // Decode GIF pixel stream.


        var datum, bits, count, first, top, pi, bi;
        datum = bits = count = first = top = pi = bi = 0;

        for (i = 0; i < npix;) {
          if (top === 0) {
            if (bits < code_size) {
              // get the next byte
              datum += data[bi] << bits;
              bits += 8;
              bi++;
              continue;
            } // Get the next code.


            code = datum & code_mask;
            datum >>= code_size;
            bits -= code_size; // Interpret the code

            if (code > available || code == end_of_information) {
              break;
            }

            if (code == clear) {
              // Reset decoder.
              code_size = data_size + 1;
              code_mask = (1 << code_size) - 1;
              available = clear + 2;
              old_code = nullCode;
              continue;
            }

            if (old_code == nullCode) {
              pixelStack[top++] = suffix[code];
              old_code = code;
              first = code;
              continue;
            }

            in_code = code;

            if (code == available) {
              pixelStack[top++] = first;
              code = old_code;
            }

            while (code > clear) {
              pixelStack[top++] = suffix[code];
              code = prefix[code];
            }

            first = suffix[code] & 0xff;
            pixelStack[top++] = first; // add a new string to the table, but only if space is available
            // if not, just continue with current table until a clear code is found
            // (deferred clear code implementation as per GIF spec)

            if (available < MAX_STACK_SIZE) {
              prefix[available] = old_code;
              suffix[available] = first;
              available++;

              if ((available & code_mask) === 0 && available < MAX_STACK_SIZE) {
                code_size++;
                code_mask += available;
              }
            }

            old_code = in_code;
          } // Pop a pixel off the pixel stack.


          top--;
          dstPixels[pi++] = pixelStack[top];
          i++;
        }

        for (i = pi; i < npix; i++) {
          dstPixels[i] = 0; // clear missing pixels
        }

        return dstPixels;
      };

      exports.lzw = lzw;

      /***/
    })
/******/]);
}
function init_meme_generator() {
    try {
        // Vars
        var canvas = document.getElementById("meme_canvas");
        var selector_modal_memes = "[data-modal=memes]";
        var selector_meme_generator = selector_modal_memes + " .meme_generator";

        // Create meme
        create_meme("with_sign");

        // On click - reset
        $(selector_meme_generator + " .reset").off("click");
        $(selector_meme_generator + " .reset").on("click", function () {
            try {
                // Create meme
                create_meme(poncho_json.template);

                // Show messages
                show_messages(poncho_json.messages.reset.success);
            } catch (e) {
                // console.error(e);
            }
        });

        // On click - save
        $(selector_meme_generator + " .edit").off("click");
        $(selector_meme_generator + " .edit").on("click", function () {
            try {
                // Clear
                $(selector_meme_generator + " .meme img").remove();

                // Set active object
                set_active_object(2);

                // Show messages
                show_messages(poncho_json.messages.edit.success);
            } catch (e) {
                // console.error(e);
            }
        });

        // On click - save
        $(selector_meme_generator + " .save").off("click");
        $(selector_meme_generator + " .save").on("click", function () {
            try {
                // Clear
                $(selector_meme_generator + " .meme img").remove();

                // Remove active
                poncho_json.meme_canvas.discardActiveObject();
                poncho_json.meme_canvas.renderAll();

                // Canvas to blob
                canvas.toBlob((blob) => {
                    // New image
                    var image = new Image();

                    // URL
                    var url = URL.createObjectURL(blob);

                    // Image source
                    image.src = url;

                    // Append
                    $(selector_meme_generator + " .meme").append(image);

                    // Show messages
                    show_messages(poncho_json.messages.save.success);
                });
            } catch (e) {
                // console.error(e);
            }
        });

        // On click - download
        $(selector_meme_generator + " .download").off("click");
        $(selector_meme_generator + " .download").on("click", function () {
            try {
                // Vars
                var active_id = "";

                try {
                    // Vars
                    active_id = poncho_json.meme_canvas.getActiveObject().id
                } catch (e) {
                    // console.error(e);
                }

                // Remove active
                poncho_json.meme_canvas.discardActiveObject();
                poncho_json.meme_canvas.renderAll();

                // Canvas to blob
                canvas.toBlob((blob) => {
                    // New image
                    var image = new Image();

                    // URL
                    var url = URL.createObjectURL(blob);

                    // Create link
                    var link = document.createElement("a");
                    link.href = url;
                    link.download = "poncho_meme.png";

                    // Click
                    link.click();
                    link.remove();

                    // Set active object
                    set_active_object(active_id);

                    // Show messages
                    show_messages(poncho_json.messages.download.success);
                });
            } catch (e) {
                // console.error(e);
            }
        });

        // On click - expand
        $(selector_meme_generator + " .expand").off("click");
        $(selector_meme_generator + " .expand").on("click", function () {
            try {
                // Hide
                $(this).hide();

                // Show
                $(selector_meme_generator + " .compress").show();

                // Remove class
                $(selector_meme_generator).removeClass("compress");

                // Add class
                $(selector_meme_generator).addClass("expand");
            } catch (e) {
                // console.error(e);
            }
        });

        // On click - compress
        $(selector_meme_generator + " .compress").off("click");
        $(selector_meme_generator + " .compress").on("click", function () {
            try {
                // Hide
                $(this).hide();

                // Show
                $(selector_meme_generator + " .expand").show();

                // Remove class
                $(selector_meme_generator).removeClass("expand");

                // Add class
                $(selector_meme_generator).addClass("compress");
            } catch (e) {
                // console.error(e);
            }
        });

        // On click - select templte
        $(selector_meme_generator + " .template-button").off("click");
        $(selector_meme_generator + " .template-button").on("click", function () {
            try {
                // Remove clss
                $(selector_meme_generator + " .template-button").removeClass("active");

                // Add class
                $(this).addClass("active");

                // Vars
                var template = $(this).attr("data-template");

                // Create meme
                create_meme(template);
            } catch (e) {
                // console.error(e);
            }
        });
    } catch (e) {
        // console.error(e);
    }
}

function create_meme(template) {
    try {
        // Vars
        var selector_modal_memes = "[data-modal=memes]";
        var selector_meme_generator = selector_modal_memes + " .meme_generator";

        // Clear
        $(selector_meme_generator + " .meme img").remove();

        try {
            clearTimeout(poncho_json.meme_canvas_timeout);

            // Destroy fabric
            poncho_json.meme_canvas.dispose();
            poncho_json.meme_canvas = "";

            var c = document.getElementById('meme_canvas')
            var context = c.getContext('2d');
            context.clearRect(0, 0, c.width, c.height);
        } catch (e) {
            // console.error(e);
        }

        // New fabric canvas
        poncho_json.meme_canvas = new fabric.Canvas("meme_canvas");

        // Defaults
        fabric.InteractiveFabricObject.ownDefaults = {
            ...fabric.InteractiveFabricObject.ownDefaults,
            cornerSize: 30,
            touchCornerSize: 40,
            cornerStrokeColor: "#1d48ff",
            cornerColor: "lightblue",
            cornerStyle: "circle",
            padding: 30,
            transparentCorners: false,
            cornerDashArray: [2, 2],
            borderColor: "#ffa51f",
            borderDashArray: [3, 1, 3],
            borderScaleFactor: 3
        }

        // Check if
        if (!check_value_defined(template)) {
            // Vars
            template = "with_sign";
        }

        // Set
        poncho_json.template = template;

        // Check if
        if (template == "truck") {
            // Add gif
            add_gif("/dist/img/memes/templates/" + template + ".gif?cv=3");
        } else {
            // Add image to canvas
            fabric.Image.fromURL("/dist/img/memes/templates/" + template + ".png?v=3").then((image) => {
                // Set fabric dimensions to match image
                poncho_json.meme_canvas.setHeight(image.height);
                poncho_json.meme_canvas.setWidth(image.width);

                // Set attributes
                image.set({
                    hasControls: false,
                    hoverCursor: "auto",
                    id: 1,
                    selectable: false
                });

                // Add image
                poncho_json.meme_canvas.add(image);

                // Check if
                if (template == "with_sign") {
                    // Textbox
                    var text_object = new fabric.Textbox("Create Your\nPoncho Meme", {
                        fontFamily: "pricedown",
                        fontSize: image.height / 10,
                        id: 1,
                        left: image.width / 2,
                        originX: "center",
                        textAlign: "center",
                        top: image.height / 6,
                        width: image.width / 1.5
                    });
                } else if (template == "change_my_mind") {
                    // Textbox
                    var text_object = new fabric.Textbox("Create Your\nPoncho Meme", {
                        fontFamily: "pricedown",
                        fontSize: image.height / 13,
                        id: 2,
                        left: image.width / 2,
                        originX: "center",
                        textAlign: "center",
                        top: image.height / 1.515,
                        width: image.width / 2
                    });
                } else if (template == "smart") {
                    // Textbox
                    var text_object = new fabric.Textbox("Create Your\nPoncho Meme", {
                        fontFamily: "pricedown",
                        fontSize: image.height / 13,
                        id: 3,
                        left: image.width / 1.282,
                        originX: "center",
                        textAlign: "center",
                        top: image.height / 13.5,
                        width: image.width / 4
                    });
                } else if (template == "drake_hotline_bling") {
                    // Textbox
                    var text_object = new fabric.Textbox("Poncho\nHate", {
                        fontFamily: "pricedown",
                        fontSize: image.height / 13,
                        id: 3,
                        left: image.width / 1.315,
                        originX: "center",
                        textAlign: "center",
                        top: image.height / 6.6,
                        width: image.width / 3
                    });

                    var text_object_two = new fabric.Textbox("Poncho\nLike", {
                        fontFamily: "pricedown",
                        fontSize: image.height / 13,
                        id: 3,
                        left: image.width / 1.315,
                        originX: "center",
                        textAlign: "center",
                        top: image.height / 1.53,
                        width: image.width / 3
                    });
                } else if (template == "truck") {
                    // Textbox
                    var text_object = new fabric.Textbox("Create Your\nPoncho Meme", {
                        fontFamily: "pricedown",
                        fontSize: image.height / 13,
                        id: 3,
                        left: image.width / 1.282,
                        originX: "center",
                        textAlign: "center",
                        top: image.height / 13.5,
                        width: image.width / 4
                    });
                } else {
                    // Textbox
                    var text_object = new fabric.Textbox("Create Your\nPoncho Meme", {
                        fontFamily: "pricedown",
                        fontSize: image.height / 10,
                        id: 1,
                        left: image.width / 2,
                        originX: "center",
                        textAlign: "center",
                        top: image.height / 6,
                        width: image.width / 1.5
                    });
                }

                // Add text
                poncho_json.meme_canvas.add(text_object);
                // poncho_json.meme_canvas.centerObjectH(text_object);
                poncho_json.meme_canvas.setActiveObject(text_object);

                // Check if
                if (text_object_two) {
                    // Add text
                    poncho_json.meme_canvas.add(text_object_two);
                }
            });
        }
    } catch (e) {
        // console.error(e);
    }
}

function set_active_object(active_id) {
    try {
        // Loop
        poncho_json.meme_canvas.getObjects().forEach(function (object) {
            // Check if
            if (object.id == active_id) {
                // Set active
                poncho_json.meme_canvas.setActiveObject(object);
                poncho_json.meme_canvas.renderAll();
            }
        })
    } catch (e) {
        // console.error(e);
    }
}